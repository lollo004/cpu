$date
	Thu Jun 12 00:21:12 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module tb_cpu $end
$var wire 16 ! PC [15:0] $end
$var wire 16 " instr [15:0] $end
$var wire 1 # zero_flag $end
$var reg 1 $ clk $end
$var reg 1 % rst $end
$var integer 32 & cycle_count [31:0] $end
$scope function decode_instr $end
$var reg 16 ' instr [15:0] $end
$upscope $end
$scope module uut $end
$var wire 1 ( branch_condition $end
$var wire 1 $ clk $end
$var wire 1 % rst $end
$var wire 1 ) update_zero $end
$var wire 16 * write_data [15:0] $end
$var wire 4 + regfile_write_reg [3:0] $end
$var wire 4 , regfile_read_reg2 [3:0] $end
$var wire 1 - reg_write $end
$var wire 1 . reg_dst $end
$var wire 16 / read_data2 [15:0] $end
$var wire 16 0 read_data1 [15:0] $end
$var wire 4 1 opcode [3:0] $end
$var wire 16 2 next_PC [15:0] $end
$var wire 1 3 mem_write $end
$var wire 1 4 mem_to_reg $end
$var wire 16 5 mem_read_data [15:0] $end
$var wire 1 6 mem_read $end
$var wire 16 7 mem_addr [15:0] $end
$var wire 1 8 jump $end
$var wire 16 9 instruction [15:0] $end
$var wire 1 : branch $end
$var wire 1 ; alu_zero $end
$var wire 16 < alu_result [15:0] $end
$var wire 2 = alu_op [1:0] $end
$var wire 16 > absolute_target [15:0] $end
$var wire 12 ? abs_address [11:0] $end
$var wire 4 @ Rt [3:0] $end
$var wire 4 A Rs [3:0] $end
$var wire 4 B Rd [3:0] $end
$var wire 16 C PC_plus_2 [15:0] $end
$var reg 16 D PC [15:0] $end
$var reg 1 E zero_flag $end
$scope module alu_inst $end
$var wire 1 ; zero $end
$var wire 2 F op [1:0] $end
$var wire 16 G b [15:0] $end
$var wire 16 H a [15:0] $end
$var reg 16 I result [15:0] $end
$upscope $end
$scope module control_inst $end
$var wire 4 J opcode [3:0] $end
$var reg 2 K alu_op [1:0] $end
$var reg 1 L alu_src $end
$var reg 1 : branch $end
$var reg 1 8 jump $end
$var reg 1 6 mem_read $end
$var reg 1 4 mem_to_reg $end
$var reg 1 3 mem_write $end
$var reg 1 . reg_dst $end
$var reg 1 - reg_write $end
$upscope $end
$scope module dmem_inst $end
$var wire 16 M addr [15:0] $end
$var wire 1 $ clk $end
$var wire 1 6 mem_read $end
$var wire 1 3 mem_write $end
$var wire 16 N write_data [15:0] $end
$var reg 16 O read_data [15:0] $end
$upscope $end
$scope module imem_inst $end
$var wire 16 P addr [15:0] $end
$var reg 16 Q instruction [15:0] $end
$upscope $end
$scope module regfile_inst $end
$var wire 1 $ clk $end
$var wire 4 R read_reg1 [3:0] $end
$var wire 4 S read_reg2 [3:0] $end
$var wire 1 % rst $end
$var wire 16 T write_data [15:0] $end
$var wire 1 - write_en $end
$var wire 4 U write_reg [3:0] $end
$var reg 16 V read_data1 [15:0] $end
$var reg 16 W read_data2 [15:0] $end
$var integer 32 X i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b10000 X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
b0 P
bx O
bx N
bx M
xL
bx K
bx J
bx I
bx H
bx G
bx F
0E
b0 D
b10 C
bx B
bx A
bx @
bx ?
b0xxxxxxxxxxxx0 >
bx =
bx <
x;
x:
bx 9
x8
bx 7
x6
bx 5
x4
x3
b0xxxxxxxxxxxx0 2
bx 1
bx 0
bx /
x.
x-
bx ,
bx +
bx *
x)
x(
bx '
b0 &
1%
0$
0#
bx "
b0 !
$end
#5000
b1 &
b10000 X
1$
#10000
0$
0%
#15000
bx 2
b10 &
bx C
b0xxxxxxxxxxxx0 !
b0xxxxxxxxxxxx0 D
b0xxxxxxxxxxxx0 P
1$
#20000
0$
#25000
b11 &
bx !
bx D
bx P
1$
#30000
0$
#35000
b100 &
1$
#40000
0$
#45000
b101 &
1$
#50000
0$
#55000
b110 &
1$
#60000
0$
#65000
b111 &
1$
#70000
0$
#75000
b1000 &
1$
#80000
0$
#85000
b1001 &
1$
#90000
0$
#95000
b1010 &
1$
#100000
0$
#105000
b1011 &
1$
#110000
0$
#115000
b1100 &
1$
#120000
0$
#125000
b1101 &
1$
#130000
0$
#135000
b1110 &
1$
#140000
0$
#145000
b1111 &
1$
#150000
0$
#155000
b10000 &
1$
#160000
0$
#165000
b10001 &
1$
#170000
0$
#175000
b10010 &
1$
#180000
0$
#185000
b10011 &
1$
#190000
0$
#195000
b10100 &
1$
#200000
0$
#205000
b10101 &
1$
